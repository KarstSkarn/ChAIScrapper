using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using YoutubeExplode;
using YoutubeExplode.Videos;
using YoutubeExplode.Videos.ClosedCaptions;

namespace ChAIScrapperWF
{
    public class YTVirtualWatch
    {
        public string YTUPLOADER { get; set; }
        public string YTTITLE { get; set; }
        public string YTDESCRIPTION { get; set; }
        public string YTMAINCOMMENT { get; set; } // YoutubeExplode no saca comentarios, dejalo vacío o adapta con otra API
        public TimeSpan LENGTH { get; set; }
        public List<YTCaptions> YTCAPTIONS { get; set; }
    }

    public class YTCaptions
    {
        public TimeSpan TIME { get; set; }
        public string CAPTION { get; set; }
    }

    public static class ChAIExternal
    {
        private static readonly YoutubeClient ytClient = new YoutubeClient();

        public static async Task<YTVirtualWatch> GetYouTubeSubtitlesAndDetailsAsync(string videoUrl)
        {
            try
            {
                // Extraer el ID del video desde la URL
                var videoId = VideoId.Parse(videoUrl);

                // Descargar detalles del video
                var video = await ytClient.Videos.GetAsync(videoId);

                // Metadata básico
                var uploader = RemoveNonBmpCharacters(video.Author.ChannelTitle);
                var title = RemoveNonBmpCharacters(video.Title);
                var description = RemoveNonBmpCharacters(video.Description);
                var length = video.Duration ?? TimeSpan.Zero;

                // YoutubeExplode no trae comentarios, así que lo dejamos vacío
                string mostLikedComment = "No comments available (use YouTube API separately if needed)";

                // Intentar obtener subtítulos cerrados
                var trackManifest = await ytClient.Videos.ClosedCaptions.GetManifestAsync(videoId);

                List<YTCaptions> captionsList = new List<YTCaptions>();

                // Prioriza subtítulos manuales en inglés, sino automático, sino ninguno
                ClosedCaptionTrackInfo selectedTrack =
                    trackManifest.Tracks
                        .Where(t => t.Language.Code == Global.preferredLanguageCode && !t.IsAutoGenerated)
                        .FirstOrDefault()
                    ?? trackManifest.Tracks
                        .Where(t => t.Language.Code == Global.preferredLanguageCode && t.IsAutoGenerated)
                        .FirstOrDefault()
                    ?? trackManifest.Tracks.FirstOrDefault();

                if (selectedTrack != null)
                {
                    var captions = await ytClient.Videos.ClosedCaptions.GetAsync(selectedTrack);

                    var captionsProperty = captions.GetType().GetProperty("Captions");
                    if (captionsProperty != null)
                    {
                        var innerCaptions = captionsProperty.GetValue(captions) as IEnumerable<ClosedCaption>;
                        if (innerCaptions != null)
                        {
                            captionsList = innerCaptions
                                .Select(caption => new YTCaptions
                                {
                                    TIME = caption.Offset,
                                    CAPTION = RemoveNonBmpCharacters(caption.Text)
                                })
                                .ToList();
                        }
                        else
                        {
                            captionsList = new List<YTCaptions>();
                        }
                    }
                    else
                    {
                        // Si no hay propiedad Captions, tal vez no hay subtítulos disponibles
                        captionsList = new List<YTCaptions>();
                    }
                }


                return new YTVirtualWatch
                {
                    YTUPLOADER = uploader,
                    YTTITLE = title,
                    YTDESCRIPTION = description,
                    YTMAINCOMMENT = mostLikedComment,
                    LENGTH = length,
                    YTCAPTIONS = captionsList
                };
            }
            catch (Exception ex)
            {
                ChAIO.WriteGeneral("[Exception] " + ex.ToString());
                return new YTVirtualWatch
                {
                    YTUPLOADER = "-1",
                    YTTITLE = "-1",
                    YTCAPTIONS = null,
                    YTDESCRIPTION = "-1",
                    YTMAINCOMMENT = "-1",
                    LENGTH = TimeSpan.Zero
                };
            }
        }

        public static string YTGetCaptions(YTVirtualWatch ytWatchData, TimeSpan start, TimeSpan end)
        {
            if (end > ytWatchData.LENGTH)
            {
                end = ytWatchData.LENGTH;
            }

            var filteredCaptions = ytWatchData.YTCAPTIONS
                .FindAll(caption => caption.TIME >= start && caption.TIME <= end);

            string result = string.Join(" ", filteredCaptions.ConvertAll(caption => caption.CAPTION));
            return result;
        }

        public static string RemoveNonBmpCharacters(string input)
        {
            if (string.IsNullOrEmpty(input))
                return input;

            var sb = new System.Text.StringBuilder(input.Length);

            foreach (var ch in input.Normalize(NormalizationForm.FormC))
            {
                if (ch <= 0xFFFF && !char.IsSurrogate(ch) && !char.IsControl(ch))
                {
                    sb.Append(ch);
                }
            }

            return sb.ToString();
        }
    }
}
